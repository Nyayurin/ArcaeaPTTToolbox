package cn.yurin.arcaea.ptt.toolbox

import androidx.compose.foundation.*
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.selection.SelectionContainer
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.layer.GraphicsLayer
import androidx.compose.ui.graphics.rememberGraphicsLayer
import androidx.compose.ui.layout.onSizeChanged
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import com.github.panpf.sketch.AsyncImage
import com.github.panpf.sketch.LocalPlatformContext
import com.github.panpf.sketch.request.ImageRequest
import com.github.panpf.sketch.util.Size
import io.github.vinceglb.filekit.core.FileKit
import io.ktor.client.call.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.datetime.*
import kotlinx.datetime.format.char

val dateTimeFormat = LocalDateTime.Format {
	year()
	char('-')
	monthNumber()
	char('-')
	dayOfMonth()
	char(' ')
	hour()
	char(':')
	minute()
	char(':')
	second()
}

@Suppress("UnusedMaterial3ScaffoldPaddingParameter")
@Composable
fun PTT(user: User, onBack: () -> Unit) {
	var user by remember { mutableStateOf(user) }
	var instant by remember { mutableStateOf(Clock.System.now()) }

	val layer = rememberGraphicsLayer()
	val verticalScrollState = rememberScrollState()
	val horizontalScrollState = rememberScrollState()
	val snackBarState = remember { SnackbarHostState() }

	var currentDialog by remember { mutableStateOf<PTTDialog?>(null) }
	var onDisLoading by remember { mutableStateOf<(() -> Unit)?>(null) }
	var loading by remember { mutableStateOf(false) }

	LaunchedEffect(Unit) {
		while (true) {
			delay(100)
			instant = Clock.System.now()
		}
	}

	BackHandler(onBack)
	Scaffold(
		snackbarHost = { SnackbarHost(snackBarState) }
	) {
		BoxWithScrollbar(
			verticalState = verticalScrollState,
			horizontalState = horizontalScrollState
		) {
			Column {
				TopBar(
					layer = layer,
					snackBarState = snackBarState,
					instant = instant,
					onBack = onBack,
					onChangeUser = { user = it },
					onChangeLoading = { loading = it },
					onChangeDisLoading = { onDisLoading = it }
				)
				Box(
					modifier = Modifier
						.verticalScroll(verticalScrollState)
						.horizontalScroll(horizontalScrollState)
				) {
					val density = LocalDensity.current
					var dpSize by remember { mutableStateOf(IntSize.Zero) }
					Surface(
						color = MaterialTheme.colorScheme.background,
						modifier = Modifier.drawToLayer(layer, dpSize)
					) {
						Column(
							horizontalAlignment = Alignment.CenterHorizontally,
							verticalArrangement = Arrangement.spacedBy(32.dp),
							modifier = Modifier
								.onSizeChanged {
									dpSize = with(density) {
										IntSize(
											width = it.width.toDp().value.toInt(),
											height = it.height.toDp().value.toInt()
										)
									}
								}
								.padding(16.dp)
								.width(1514.dp)
						) {
							Header(
								user = user,
								relPttFloor = floorPtt(user.ptt.real),
								b30PttFloor = floorPtt(user.ptt.b30),
								r10PttFloor = floorPtt(user.ptt.r10),
								b10PttFloor = floorPtt(user.ptt.b10),
								maxPttFloor = floorPtt(user.ptt.max),
								minPttFloor = floorPtt(user.ptt.min),
								onDialog = { currentDialog = PTTDialog.User }
							)
							Column(
								horizontalAlignment = Alignment.CenterHorizontally,
								verticalArrangement = Arrangement.spacedBy(8.dp)
							) {
								HorizontalDivider()
								Text(
									text = "Best 30",
									style = MaterialTheme.typography.headlineLarge
								)
								TrackList(
									list = user.best,
									onDialog = { currentDialog = it }
								)
							}
							Column(
								horizontalAlignment = Alignment.CenterHorizontally,
								verticalArrangement = Arrangement.spacedBy(8.dp)
							) {
								HorizontalDivider()
								Text(
									text = "Recent 10",
									style = MaterialTheme.typography.headlineLarge
								)
								TrackList(
									list = user.recent,
									onDialog = { currentDialog = it }
								)
							}
							Text(
								text = buildString {
									append("Generated by Arcaea PTT Toolbox")
									append("(https://github.com/Nyayurin/ArcaeaPTTToolbox)")
									append(" @ ")
									append(
										instant.toLocalDateTime(TimeZone.currentSystemDefault()).format(dateTimeFormat)
									)
								},
								style = MaterialTheme.typography.headlineSmall
							)
						}
					}
				}
			}
			currentDialog?.let {
				BackHandler { currentDialog = null }
				Dialog(
					onDismissRequest = { currentDialog = null }
				) {
					Card(
						shape = RoundedCornerShape(16.dp)
					) {
						SelectionContainer {
							Column(
								verticalArrangement = Arrangement.spacedBy(8.dp),
								modifier = Modifier.padding(16.dp)
							) {
								when (it) {
									is PTTDialog.User -> {
										Text(
											text = "PTT: ${user.ptt.real}"
										)
										Text(
											text = "B30: ${user.ptt.b30}"
										)
										Text(
											text = "R10: ${user.ptt.r10}"
										)
										Text(
											text = "B10: ${user.ptt.b10}"
										)
										Text(
											text = "Max: ${user.ptt.max}"
										)
										Text(
											text = "Min: ${user.ptt.min}"
										)
									}

									is PTTDialog.Track -> {
										Text(
											text = "Title: ${it.track.title}"
										)
										Text(
											text = "Difficult: ${it.track.difficulty}"
										)
										Text(
											text = "Chart constant: ${it.track.chartConstant}"
										)
										AsyncImage(
											uri = it.track.img.absolutePath(),
											contentDescription = null
										)
										Text(
											text = "Score: ${it.track.score}"
										)
										Text(
											text = "PTT: ${it.track.ptt}"
										)
										Text(
											text = buildString {
												append("Pure: ${it.track.pure}")
												append("(+${it.track.pure - it.track.lowerPure}")
												append(", ")
												append("-${it.track.lowerPure})")
											}
										)
										Text(
											text = "Far: ${it.track.far}"
										)
										Text(
											text = "Lost: ${it.track.lost}"
										)
										Text(
											text = "Notes: ${it.track.notes}"
										)
										it.track.rating?.let { rating ->
											Text(
												text = buildString {
													append("Rating score: ")
													append(rating.max - rating.lost)
													append(" / ")
													append(rating.max)
												}
											)
											Text(
												text = "Rating lost score: ${rating.lost}"
											)
											Text(
												text = "Rating score part: ${rating.score}"
											)
											Text(
												text = "Rating acc part: ${rating.acc}"
											)
										}
										Text(
											text = "Play at: ${
												it.track.instant.toLocalDateTime(TimeZone.currentSystemDefault())
													.format(dateTimeFormat)
											}"
										)
									}
								}
							}
						}
					}
				}
			}
			if (loading) {
				BackHandler(onDisLoading!!)
				Dialog(
					onDismissRequest = onDisLoading!!
				) {
					Card(
						shape = RoundedCornerShape(16.dp)
					) {
						CircularProgressIndicator(
							modifier = Modifier.padding(16.dp)
						)
					}
				}
			}
		}
	}
}

@Composable
fun TopBar(
	layer: GraphicsLayer,
	snackBarState: SnackbarHostState,
	instant: Instant,
	onBack: () -> Unit,
	onChangeUser: (User) -> Unit,
	onChangeLoading: (Boolean) -> Unit,
	onChangeDisLoading: ((() -> Unit)?) -> Unit
) {
	val scope = rememberCoroutineScope()
	Row(
		verticalAlignment = Alignment.CenterVertically,
		horizontalArrangement = Arrangement.spacedBy(8.dp),
		modifier = Modifier
			.fillMaxWidth()
			.background(MaterialTheme.colorScheme.surfaceContainer)
			.padding(8.dp)
			.statusBarsPadding()
	) {
		Button(
			onClick = {
				scope.launch {
					onBack()
				}
			}
		) {
			Text(
				text = "返回"
			)
		}
		Button(
			onClick = {
				scope.launch {
					onChangeLoading(true)
					val bitmap = layer.toImageBitmap()
					val deferred = async(Dispatchers.IO) {
						val byteArray = bitmap.toByteArray()
						val time = instant.toLocalDateTime(TimeZone.currentSystemDefault()).format(
							LocalDateTime.Format {
								year()
								char('_')
								monthNumber()
								char('_')
								dayOfMonth()
								char('-')
								hour()
								char('_')
								minute()
								char('_')
								second()
							}
						)
						FileKit.saveFile(
							bytes = byteArray,
							baseName = "PTT_$time",
							extension = "png"
						)
						onChangeLoading(false)
						onChangeDisLoading(null)
					}
					onChangeDisLoading {
						deferred.cancel()
						onChangeLoading(false)
						onChangeDisLoading(null)
					}
				}
			}
		) {
			Text(
				text = "保存图片"
			)
		}
		Button(
			onClick = {
				scope.launch {
					try {
						onChangeLoading(true)
						val deferred = async {
							val userDeferred = async(Dispatchers.IO) {
								loadUser(sid!!).body<UserResponse>().value!!
							}
							val scoreResponseDeferred = async(Dispatchers.IO) {
								client.get("https://webapi.lowiro.com/webapi/score/rating/me") {
									cookie("sid", sid!!)
								}
							}
							val user = userDeferred.await()
							val scoreResponse = scoreResponseDeferred.await()
							val score = scoreResponse.body<ScoreResponse>()
							if (score.success) {
								onChangeUser(User.from(user, score.value!!))
							} else {
								snackBarState.showSnackbar("生成失败: ${scoreResponse.bodyAsText()}")
							}
						}
						onChangeDisLoading {
							deferred.cancel()
							onChangeLoading(false)
							onChangeDisLoading(null)
						}
						deferred.await()
					} catch (e: Exception) {
						snackBarState.showSnackbar("异常: $e")
					} finally {
						onChangeLoading(false)
						onChangeDisLoading(null)
					}
				}
			}
		) {
			Text(
				text = "刷新数据"
			)
		}
	}
}

@Composable
fun Header(
	user: User,
	relPttFloor: String,
	b30PttFloor: String,
	r10PttFloor: String,
	b10PttFloor: String,
	maxPttFloor: String,
	minPttFloor: String,
	onDialog: () -> Unit
) {
	Row(
		verticalAlignment = Alignment.CenterVertically,
		horizontalArrangement = Arrangement.SpaceBetween,
		modifier = Modifier.fillMaxWidth()
	) {
		Box {
			Box(
				contentAlignment = Alignment.CenterStart,
				modifier = Modifier.height(180.dp)
			) {
				when (user.banner) {
					null -> Spacer(
						modifier = Modifier
							.size(564.dp, 74.dp)
							.padding(start = 90.dp)
					)

					else -> AsyncImage(
						request = ImageRequest
							.Builder(
								context = LocalPlatformContext.current,
								uri = user.banner.path.absolutePath()
							)
							.size(Size.Origin)
							.build(),
						contentDescription = null,
						modifier = Modifier
							.size(564.dp, 74.dp)
							.padding(start = 90.dp)
							.graphicsLayer {
								scaleX = -1F
							}
					)
				}
				Box {
					AsyncImage(
						request = ImageRequest
							.Builder(
								context = LocalPlatformContext.current,
								uri = user.character.path.absolutePath()
							)
							.size(Size.Origin)
							.build(),
						contentDescription = null,
						modifier = Modifier
							.size(170.dp)
							.clickable(onClick = onDialog)
					)
					Box(
						contentAlignment = Alignment.Center,
						modifier = Modifier
							.offset(80.dp, 80.dp)
					) {
						AsyncImage(
							request = ImageRequest
								.Builder(
									context = LocalPlatformContext.current,
									uri = user.ptt.path.absolutePath()
								)
								.size(Size.Origin)
								.build(),
							contentDescription = null,
							modifier = Modifier.size(120.dp)
						)
						Text(
							text = relPttFloor,
							color = Color.White,
							style = MaterialTheme.typography.titleMedium
						)
					}
				}
			}
			Text(
				text = user.name,
				color = colorOnBanner(user.banner?.id),
				style = MaterialTheme.typography.headlineLarge,
				modifier = Modifier
					.align(Alignment.CenterStart)
					.padding(start = 200.dp)
			)
			Text(
				text = "ID: ${user.id}",
				style = MaterialTheme.typography.titleLarge,
				modifier = Modifier
					.align(Alignment.BottomCenter)
					.offset(y = (-10).dp)
			)
		}
		Column(
			horizontalAlignment = Alignment.CenterHorizontally,
			verticalArrangement = Arrangement.spacedBy(8.dp),
			modifier = Modifier.width(200.dp)
		) {
			PTTRow("B30PTT:", b30PttFloor)
			PTTRow("R10PTT:", r10PttFloor)
			PTTRow("B10PTT:", b10PttFloor)
			PTTRow("MaxPTT:", maxPttFloor)
			PTTRow("MinPTT:", minPttFloor)
		}
	}
}

@Composable
fun PTTRow(left: String, right: String) {
	Row(
		horizontalArrangement = Arrangement.SpaceBetween,
		modifier = Modifier.fillMaxWidth()
	) {
		Text(
			text = left,
			style = MaterialTheme.typography.titleLarge
		)
		Text(
			text = right,
			style = MaterialTheme.typography.titleLarge
		)
	}
}

@Composable
fun TrackList(list: List<User.Track>, onDialog: (PTTDialog.Track) -> Unit) {
	Column(
		verticalArrangement = Arrangement.spacedBy(16.dp)
	) {
		repeat(list.size / 5) { y ->
			Row(
				horizontalArrangement = Arrangement.spacedBy(16.dp)
			) {
				for (x in 0 until 5) {
					val index = y * 5 + x
					TrackCard(
						index = index,
						track = list[y * 5 + x],
						onDialog = onDialog
					)
				}
			}
		}
	}
}

@Composable
fun TrackCard(index: Int, track: User.Track, onDialog: (PTTDialog.Track) -> Unit) {
	Card(
		onClick = { onDialog(PTTDialog.Track(track)) },
		colors = CardDefaults.cardColors(
			containerColor = when {
				track.isPM() -> MaterialTheme.colorScheme.primaryContainer
				track.isFR() -> MaterialTheme.colorScheme.tertiaryContainer
				else -> MaterialTheme.colorScheme.surfaceContainerHighest
			}
		),
		shape = RoundedCornerShape(16.dp),
		modifier = Modifier.width(290.dp)
	) {
		Column(
			verticalArrangement = Arrangement.spacedBy(4.dp),
			modifier = Modifier.padding(10.dp)
		) {
			Row(
				horizontalArrangement = Arrangement.SpaceBetween,
				modifier = Modifier.fillMaxWidth()
			) {
				Row(
					modifier = Modifier
						.weight(1F)
						.padding(end = 8.dp)
				) {
					Text(
						text = "[${track.difficulty}${track.chartConstant}]",
						maxLines = 1,
						style = MaterialTheme.typography.titleSmall,
						color = track.difficulty.color
					)
					Text(
						text = track.title,
						maxLines = 1,
						style = MaterialTheme.typography.titleSmall,
						overflow = TextOverflow.Ellipsis
					)
				}
				Text(
					text = "#${index + 1}",
					maxLines = 1,
					style = MaterialTheme.typography.titleSmall
				)
			}
			Row(
				verticalAlignment = Alignment.CenterVertically,
				horizontalArrangement = Arrangement.spacedBy(8.dp)
			) {
				Box(
					modifier = Modifier
						.size(150.dp)
						.clip(RoundedCornerShape(8.dp))
				) {
					AsyncImage(
						request = ImageRequest
							.Builder(LocalPlatformContext.current, track.img.absolutePath())
							.size(Size.Origin)
							.build(),
						contentDescription = null,
						modifier = Modifier.fillMaxSize()
					)
					Text(
						text = makeScoreString(track.score),
						maxLines = 1,
						color = Color.White,
						style = MaterialTheme.typography.headlineSmall,
						textAlign = TextAlign.Center,
						modifier = Modifier
							.align(Alignment.BottomCenter)
							.fillMaxWidth()
							.background(Brush.verticalGradient(listOf(Color(0x00000000), Color(0xFF000000))))
					)
				}
				Box(
					contentAlignment = Alignment.Center,
					modifier = Modifier.fillMaxSize()
				) {
					Column(
						verticalArrangement = Arrangement.spacedBy(8.dp)
					) {
						Text(
							text = roundPtt(track.ptt),
							maxLines = 1,
							style = MaterialTheme.typography.headlineSmall
						)
						Column {
							Text(
								text = "P: ${track.pure}(-${track.lowerPure})",
								maxLines = 1,
								style = MaterialTheme.typography.bodySmall.copy(
									brush = Brush.verticalGradient(listOf(Color(0xFF9B1691), Color(0xFF4176B9)))
								),
							)
							Text(
								text = "F: ${track.far}",
								maxLines = 1,
								style = MaterialTheme.typography.bodySmall.copy(
									brush = Brush.verticalGradient(listOf(Color(0xFFB86800), Color(0xFFD29400)))
								),
							)
							Text(
								text = "L: ${track.lost}",
								maxLines = 1,
								style = MaterialTheme.typography.bodySmall.copy(
									brush = Brush.verticalGradient(listOf(Color(0xFFDE0B4C), Color(0xFF633348)))
								),
							)
						}
						Text(
							text = "LS: ${floorPtt(track.rating?.lost ?: 0.0)}",
							maxLines = 1,
							style = MaterialTheme.typography.bodySmall,
						)
						Text(
							text = calculatorTime(track.instant),
							maxLines = 1,
							style = MaterialTheme.typography.bodySmall
						)
					}
				}
			}
		}
	}
}